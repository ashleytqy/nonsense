diff --git a/ex3/README.txt b/ex3/README.txt
index 5eda569..1fc3e6b 100644
--- a/ex3/README.txt
+++ b/ex3/README.txt
@@ -1,11 +1,36 @@
-# README.txt contains instructions how to build and run your code.
+Required Libraries
+- grpc
+- string
+- random
+- concurrent
+- time
+- sys
 
-# TODO: document how to invoke protoc in order to generate the stubs in your
-# language of choice.
-# YOUR INSTRUCTIONS GO HERE
+Building
+- cd ex3
+- virtualenv venv OR virtualenv --python=/usr/local/bin/python2.7 venv
+- source venv/bin/activate
+- python -m pip install --upgrade pip
+- python -m pip install grpcio
+- python -m pip install grpcio-tools
+- pip install concurrent
+- chmod +x moderator
 
-# TODO: document how to build your server and client code (if applicable)
-# YOUR INSTRUCTIONS GO HERE
+# Invoke protoc in order to generate the stubs
+- python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. consultation.proto
+- python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. debate.proto
 
-# TODO: document how run your server (on localhost)
-# YOUR INSTRUCTIONS GO HERE
+# Runing server on localhost
+- in another terminal, cd ex3
+- python server.py
+- ctrl-c to kill server
+
+# Using command line tool
+- [ensure server is running on localhost]
+- ./moderator <answer OR elaborate> question [blah_run...]
+
+If using 'answer':
+- ./moderator answer what is your name
+
+If using 'elaborate':
+- ./moderator elaborate taxes 2 4 5# README.txt contains instructions how to build and run your code.
diff --git a/ex3/client.py b/ex3/client.py
new file mode 100644
index 0000000..435e6e1
--- /dev/null
+++ b/ex3/client.py
@@ -0,0 +1,24 @@
+import grpc
+import string
+
+import debate_pb2
+import debate_pb2_grpc
+
+def run(type, args):
+
+  channel = grpc.insecure_channel('localhost:50051')
+  stub = debate_pb2_grpc.CandidateStub(channel)
+
+  if type == "answer":
+    # always 2 arguments
+    question = string.join(args[0:])
+    response = stub.Answer(debate_pb2.AnswerRequest(question=question))
+
+  elif type == "elaborate":
+    # 3 or more arguments
+    topic = args[0]
+    runs = args[1:]
+    runs = [int(run) for run in runs]
+    response = stub.Elaborate(debate_pb2.ElaborateRequest(topic=topic, blah_run=runs))
+  
+  print(response.answer)
diff --git a/ex3/debate.proto b/ex3/debate.proto
new file mode 100644
index 0000000..679823e
--- /dev/null
+++ b/ex3/debate.proto
@@ -0,0 +1,30 @@
+syntax = "proto3";
+
+// the candidate service definition
+service Candidate {
+  // sends an answer
+  rpc Answer(AnswerRequest) returns (AnswerReply) {}
+  // sends an elaborate answer
+  rpc Elaborate(ElaborateRequest) returns (ElaborateReply) {}
+}
+
+// the answer request containing the question
+message AnswerRequest {
+  string question = 1;
+}
+
+// the answer reply containing the answer
+message AnswerReply {
+  string answer = 1;
+}
+
+// the elaborate answer request containing the topic
+message ElaborateRequest {
+  string topic = 1;
+  repeated int32 blah_run = 2;
+}
+
+// the elaborate reply containing the answer
+message ElaborateReply {
+  string answer = 1;
+}
diff --git a/ex3/moderator b/ex3/moderator
new file mode 100755
index 0000000..7b214c7
--- /dev/null
+++ b/ex3/moderator
@@ -0,0 +1,11 @@
+#!/usr/bin/env python
+
+import sys
+import client
+
+def run():
+  type = sys.argv[1]
+  client.run(type, sys.argv[2:])
+
+if __name__ == '__main__':
+  run()
diff --git a/ex3/server.py b/ex3/server.py
new file mode 100644
index 0000000..eebef62
--- /dev/null
+++ b/ex3/server.py
@@ -0,0 +1,80 @@
+from concurrent import futures
+import time
+import grpc
+import string
+import random
+
+import debate_pb2
+import debate_pb2_grpc
+
+import consultation_pb2
+import consultation_pb2_grpc
+
+_ONE_DAY_IN_SECONDS = 60 * 60 * 24
+
+class Candidate(debate_pb2_grpc.CandidateServicer):
+
+  def Answer(self, request, context):
+    question = request.question
+    first_word = question.split(' ', 1)[0]
+
+    words = ['why', 'what', 'how', 'who', 'when']
+
+    if not any(first_word.lower() in w for w in words):
+      rand = random.randint(0, 1)
+
+      if rand == 1:
+        response = 'your 3 cent titanium tax goes too far'
+      else:
+        response ='your 3 cent titanium tax doesn\'t go too far enough'
+
+    else:
+      # replaces all occurrences of the word 'You' with 'I'
+      # and all occurrences of the word 'your' with 'my'
+      post_replacement = ' '.join('I' if word.lower() == 'you' else word for word in question.split())
+      post_replacement = ' '.join('my' if word.lower() == 'your' else word for word in post_replacement.split())
+
+      # Makes an RPC call with question to the external CampaignManager.Retort service
+      channel = grpc.insecure_channel('23.236.49.28:50051')
+      stub = consultation_pb2_grpc.CampaignManagerStub(channel)
+      retort = stub.Retort(consultation_pb2.RetortRequest(original_question=question)).retort
+
+      response = 'You asked me: ' + post_replacement + ' but I want to say that: ' + retort
+    return debate_pb2.AnswerReply(answer=response)
+
+  def Elaborate(self, request, context):
+    # response has repeated runs of the word 'blah' separated by 'topic'
+    # the length of each 'blah' run corresponds to a value of 'blah_run', in the order it appears
+    # if there is a single run, 'topic' is printed after it
+    # when there are no runs, only 'topic' is printed
+
+    runs = request.blah_run
+    topic = request.topic
+
+    response = ''
+    if len(runs) == 0:
+      response = topic
+    elif len(runs) == 1:
+      response = 'blah ' + topic
+    else:
+      for (index, run) in enumerate(runs):
+        response += ('blah ' * run)
+        if index < len(runs) - 1:
+          response += topic + ' '
+
+    return debate_pb2.ElaborateReply(answer=response)
+
+def serve():
+  server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
+  debate_pb2_grpc.add_CandidateServicer_to_server(Candidate(), server)
+  server.add_insecure_port('localhost:50051')
+  server.start()
+  print("hi from server!")
+  try:
+    while True:
+      time.sleep(_ONE_DAY_IN_SECONDS)
+  except KeyboardInterrupt:
+    server.stop(0)
+
+if __name__ == '__main__':
+  serve()
